<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>LVM Extent Manager</title>
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
  <script src="extents.js"></script>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    .help { background: #eef; padding: 10px; margin-bottom: 15px; border-left: 4px solid #88f; }
    textarea { width: 100%; height: 200px; margin-bottom: 10px; font-family: monospace; }
    button { margin-bottom: 10px; padding: 6px 12px; cursor: pointer; }
    .pv-container { display: flex; flex-wrap: wrap; gap: 20px; margin-bottom: 20px; }
    .pv { border: 1px solid #ccc; padding: 10px; min-width: 240px; background: #f9f9f9; }
    .pv h3 { margin-top: 0; font-size: 16px; word-break: break-word; }
    .extent { padding: 4px; margin: 2px 0; background: #e0e0ff; cursor: grab; font-size: 12px; border-left: 6px solid; position: relative; }
    .extent.free { background: #d0ffd0; border-left-color: #8c8; }
    .extent:hover { opacity: 0.9; }
    .extent.moved::after {
      content: 'moved';
      position: absolute;
      right: 4px;
      top: 2px;
      font-size: 10px;
      color: #333;
      background: #fff6b2;
      padding: 0 4px;
      border-radius: 3px;
    }
    pre { background: #eee; padding: 10px; white-space: pre-wrap; }
    .error { color: red; font-weight: bold; }
    .modal {
      position: fixed;
      top: 50%;
      left: 50%;
      width: 300px;
      transform: translate(-50%, -50%);
      background: white;
      padding: 16px;
      border: 1px solid #aaa;
      box-shadow: 0 0 10px rgba(0,0,0,0.25);
      z-index: 1000;
    }
    .modal-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      background: rgba(0,0,0,0.5);
      z-index: 999;
    }
    #splitSlider {
      width: 100%;
    }
  </style>
</head>
<body>

<h1>LVM Extent Manager</h1>

<div class="help" style="background: #ffe0e0; border-left-color: #f55;">
  ⚠️ <strong>Disclaimer:</strong> This tool is experimental, untested, and may produce incorrect or unsafe results. Use at your own risk.
</div>

<div class="help">
  <strong>Step 1:</strong> Run this command and paste the output below:<br>
  <code>pvs -o segtype,lv_name,seg_start_pe,seg_size_pe,pvseg_all,pv_name --reportformat json</code>
  <button onclick="copyPvsCommand()">Copy</button>
</div>

<textarea id="jsonInput" placeholder="Paste JSON here..."></textarea>
<button onclick="parseJSON()">Parse</button>
<div id="errorMessage" class="error"></div>

<div class="help">
  <strong>Step 2:</strong> Re-order extents:<br>
</div>

<div class="pv-container" id="pvContainer"></div>

<div class="help">
  <strong>Step 3:</strong> Copy commands:<br>
  <button onclick="generateCommands()">Generate</button>
  <button onclick="copyGeneratedCommands()">Copy</button>
</div>
<pre id="commandsOutput"># No changes yet</pre>

<div class="help">
  <strong>Step 4:</strong> Inspect logs:<br>
</div>
<pre id="debugJson"></pre>

<!-- Modal for splitting -->
<div id="modalOverlay" class="modal-overlay" style="display:none;"></div>
<div id="splitModal" class="modal" style="display:none;">
  <h4>Split Extent</h4>
  <p id="splitLabel">Size: </p>
  <input type="range" id="splitSlider" min="1" max="1" value="1" />
  <button onclick="confirmSplit()">Split</button>
  <button onclick="closeSplitModal()">Cancel</button>
</div>

<footer style="font-size: 0.9em; color: #666; text-align: center;">
  <div>
    <hr/>
    Kamil Trzciński (c) 2025 | 
    <a href="https://github.com/ayufan/lvm2defrag-web" target="_blank" rel="noopener noreferrer">GitHub</a> |
    <a href="https://ko-fi.com/ayufan" target="_blank" rel="noopener noreferrer">Buy a Coffee</a>
  </div>
</footer>

<script>
let pvOrder = [];
let loadedReport = [];

function safeId(pvName) {
  return pvName.replace(/[^a-zA-Z0-9\-_]/g, '_');
}

function hashColor(name) {
  let hash = 0;
  for (let i = 0; i < name.length; i++) {
    hash = name.charCodeAt(i) + ((hash << 5) - hash);
  }
  const hue = hash % 360;
  return `hsl(${hue}, 60%, 75%)`;
}

function copyPvsCommand() {
  const cmd = "pvs -o segtype,lv_name,seg_start_pe,seg_size_pe,pvseg_all,pv_name --reportformat json";
  navigator.clipboard.writeText(cmd);
}

function resetPVs() {
  const container = document.getElementById('pvContainer');
  container.innerHTML = '';
  pvOrder = [];
}

function createOrUpdatePV(pvName) {
  const pvId = `pv-${safeId(pvName)}`;

  let list = document.getElementById(pvId);
  if (!list) {
    if (!pvOrder.includes(pvName)) {
      pvOrder.push(pvName);
    }

    const container = document.getElementById('pvContainer');

    const div = document.createElement('div');
    div.className = 'pv';
    div.innerHTML = `
      <h3>${pvName}</h3>
      <label><input type="checkbox" class="use-indirect" data-pv="${pvName}" checked /> Use for indirect moves</label><br/>
      <label><input type="checkbox" class="use-local" data-pv="${pvName}" checked /> Use for local moves</label>
      <hr/>
    `;

    list = document.createElement('div');
    list.id = pvId;
    list.dataset.pv = pvName;

    div.appendChild(list);
    container.appendChild(div);

    new Sortable(list, {
      group: 'extents',
      animation: 150,
      onEnd: evt => {
        const item = evt.item;
        const pv_size = parseInt(item.dataset.pv_size);

        const nextEl = item.previousElementSibling || item.nextElementSibling;
        let freeSpace = 0;
        for (let el = nextEl; el; el = el.nextElementSibling) {
          if (el.dataset.lv_name)
            continue;
          freeSpace += parseInt(el.dataset.pv_size);
        }

        document.getElementById('errorMessage').innerText = '';

        if (pv_size > freeSpace) {
          if (evt.from == evt.to) {
            updatePVs();
            return;
          }
          document.getElementById('errorMessage').innerText = '❌ Not enough free space';
          evt.from.insertBefore(item, evt.from.children[evt.oldIndex]);
          return;
        }

        let left_size = pv_size;
        for (let el = nextEl; el && left_size > 0; el = el.nextElementSibling) {
          if (el.dataset.lv_name)
            continue;
          const size = parseInt(el.dataset.pv_size);
          if (left_size > size) {
            el.dataset.pv_size = 0;
            left_size -= size;
          } else {
            el.dataset.pv_size = size - left_size;
            left_size = 0;
          }
        }

        createLVFreeExtent(
          item.dataset.moved_pv_name,
          parseInt(item.dataset.moved_pv_start),
          pv_size - left_size);
        updatePVs();
      }
    });
  }

  return list;
}

function updatePVs() {
  pvOrder.forEach(pv => {
    const list = document.getElementById(`pv-${safeId(pv)}`);
    let pv_start = 0;

    for (let i = 0; i < list.children.length; i++) {
      let ext = list.children[i];
      let pv_size = parseInt(ext.dataset.pv_size);

      ext.dataset.moved_pv_start = pv_start;
      ext.dataset.moved_pv_name = pv;

      if (ext.dataset.lv_name) {
        if (ext.dataset.pv_name !== pv || parseInt(ext.dataset.pv_start) !== pv_start) {
          ext.classList.add('moved');
        } else {
          ext.classList.remove('moved');
        }
      } else {
        if (i != 0 && !list.children[i-1].dataset.lv_name) {
          ext.remove();
          ext = list.children[i-1];
          ext.dataset.pv_size = parseInt(ext.dataset.pv_size) + pv_size;
          i--;
        } else if (pv_size <= 0) {
          ext.remove();
          i--;
        }
        ext.innerText = `free:${ext.dataset.pv_size}`;
      }

      pv_start += pv_size;
    }
  });
}

function insertLVtoPV(pvName, item) {
  const list = createOrUpdatePV(pvName);
  const moved_pv_start = parseInt(item.dataset.moved_pv_start);
  for(const d of list.children) {
    if (parseInt(d.dataset.moved_pv_start) > moved_pv_start) {
      list.insertBefore(item, d);
      return;
    }
  }
  list.appendChild(item);
}

function createLVFreeExtent(pvName, pv_start, pv_size) {
  const d = document.createElement('div');
  d.className = 'extent free';
  d.innerText = `free:${pv_size}`;
  d.draggable = false;
  d.dataset.segtype = 'free';
  d.dataset.pv_start = pv_start;
  d.dataset.pv_size = pv_size;
  d.dataset.pv_name = pvName;
  d.dataset.moved_pv_name = pvName;
  d.dataset.moved_pv_start = pv_start;
  insertLVtoPV(pvName, d);
}

function createLVExtent(pvName, extent) {
  const start_pe = parseInt(extent.seg_start_pe);
  const size_pe = parseInt(extent.seg_size_pe);
  const pv_start = parseInt(extent.pvseg_start);
  const pv_size = parseInt(extent.pvseg_size);
  const index = parseInt(extent.index);

  const list = createOrUpdatePV(pvName);
  const d = document.createElement('div');
  d.className = 'extent';
  d.innerText = `${extent.lv_name} #${index}:${size_pe}`;
  d.style.borderLeftColor = hashColor(extent.lv_name);
  d.style.background = hashColor(extent.lv_name);
  d.draggable = true;
  d.dataset.segtype = extent.segtype;
  d.dataset.lv_name = extent.lv_name;
  d.dataset.lv_start = start_pe;
  d.dataset.lv_size = size_pe;
  d.dataset.pv_name = extent.pv_name;
  d.dataset.pv_start = pv_start;
  d.dataset.pv_size = pv_size;
  d.dataset.moved_pv_name = extent.pv_name;
  d.dataset.moved_pv_start = pv_start;
  d.dataset.index = index;
  insertLVtoPV(pvName, d);
}

function parseJSON() {
  try {
    const jsonInput = document.getElementById('jsonInput').value.trim();
    const input = JSON.parse(jsonInput);
    const entries = input.report[0].pv;
    const lvSegments = {};

    entries.sort((a, b) => {
      const ret = a.pv_name.localeCompare(b.pv_name);
      if (ret !== 0) return ret;
      return parseInt(a.pvseg_start) - parseInt(b.pvseg_start);
    });

    entries.forEach(entry => {
      if (!entry.lv_name) return;
      if (!lvSegments[entry.lv_name])
        lvSegments[entry.lv_name] = [];
      lvSegments[entry.lv_name].push(entry);
    });
    for(const lv in lvSegments) {
      lvSegments[lv].sort((a, b) => a.seg_start_pe - b.seg_start_pe);
      lvSegments[lv].forEach((seg, i) => {
        seg.index = i + 1;
      });
    }

    resetPVs();
    entries.forEach(entry => {
      if (entry.segtype === 'free') {
        createLVFreeExtent(entry.pv_name, entry.pvseg_start, entry.pvseg_size);
      } else {
        createLVExtent(entry.pv_name, entry);
      }
    });

    updatePVs();
    loadedReport = dumpPVs();

    localStorage.setItem('lvm_json', jsonInput);
  } catch (e) {
    document.getElementById('errorMessage').innerText = `Invalid JSON: ${e.message}`;
  }
}

function dumpPVs() {
  const output = [];

  pvOrder.forEach(pvName => {
    const list = document.getElementById(`pv-${safeId(pvName)}`);
    for (const el of list.children) {
      output.push({
        lv_name: el.dataset.lv_name || null,
        pv_name: el.dataset.pv_name,
        pv_start: parseInt(el.dataset.pv_start),
        pv_size: parseInt(el.dataset.pv_size)
      });
    }
  });

  return output;
}

function generateCommands() {
  const queue = [];
  const freeSets = new ExtentSetsWithNames();
  
  pvOrder.forEach(pv => {
    const list = document.getElementById(`pv-${safeId(pv)}`);
    for (const el of list.children) {
      if (!el.classList.contains('moved'))
        continue;

      queue.push({
        from_start: parseInt(el.dataset.pv_start),
        from_set: el.dataset.pv_name,
        to_start: parseInt(el.dataset.moved_pv_start),
        to_set: el.dataset.moved_pv_name,
        size: parseInt(el.dataset.pv_size),
        name: `${el.dataset.lv_name} #${el.dataset.index}[${el.dataset.lv_start}-${parseInt(el.dataset.lv_start) + parseInt(el.dataset.lv_size) - 1}]`
      });
    }

    freeSets.set(pv).indirectAllowed = document.querySelector(`.use-indirect[data-pv="${pv}"]`)?.checked;
    freeSets.set(pv).localAllowed = document.querySelector(`.use-local[data-pv="${pv}"]`)?.checked;
  });

  for (const loaded of loadedReport) {
    if (loaded.lv_name) continue; // Skip LV extents
    freeSets.add(loaded.pv_name, loaded.pv_start, loaded.pv_size);
  }

  let { moves, failedMoves } = planMoves(queue, freeSets);

  if (failedMoves.length > 0) {
    document.getElementById('errorMessage').innerText = `❌ Failed to find enough free space for ${failedMoves.length} extents`;
  } else {
    document.getElementById('errorMessage').innerText = '';
  }

  const commands = [];
  let extentsMoved = 0;

  for (let i = 0; i < moves.length; i++) {
    const move = moves[i];
    commands.push(
      `# Move ${move.name} ${move.type} from ${move.from_set}[${move.from_start}-${move.from_start + move.size - 1}] to ${move.to_set}[${move.to_start}-${move.to_start + move.size - 1}]`,
      `pvmove --alloc anywhere ${move.from_set}:${move.from_start}-${move.from_start + move.size - 1} ${move.to_set}:${move.to_start}-${move.to_start + move.size - 1}`,
      ``
    );

    extentsMoved += move.size;
  }

  for (let i = 0; i < failedMoves.length; i++) {
    const move = failedMoves[i];
    commands.push(
      `# Failed to move ${move.name} from ${move.from_set}[${move.from_start}-${move.from_start + move.size - 1}] to ${move.to_set}[${move.to_start}-${move.to_start + move.size - 1}]`,
      `# Not enough free space available`,
      ``
    );
  }

  commands.unshift(
    `# Total extents moved: ${extentsMoved}`,
    `# Total moves planned: ${moves.length}`,
    `# Failed moves: ${failedMoves.length}`,
    ``
  );

  document.getElementById('commandsOutput').innerText = commands.length ? commands.join('\n') : "# No changes.";
  document.getElementById('debugJson').innerText = 
    `const queue = ${JSON.stringify(queue, null, 2)};\n\n` +
    `const free = ${JSON.stringify(freeSets, null, 2)};`;
}

function copyGeneratedCommands() {
  navigator.clipboard.writeText(document.getElementById('commandsOutput').innerText);
}

// Extent splitting logic
let selectedExtent = null;

document.addEventListener("click", function (e) {
  if (e.target.classList.contains("extent") && !e.target.classList.contains("free")) {
    selectedExtent = e.target;
    const max = parseInt(selectedExtent.dataset.pv_size);
    if (max <= 1) return;
    document.getElementById("splitSlider").max = max - 1;
    document.getElementById("splitSlider").value = 1;
    document.getElementById("splitLabel").innerText = `Split ${selectedExtent.innerText} into:`;
    document.getElementById("splitModal").style.display = "block";
    document.getElementById("modalOverlay").style.display = "block";
  }
});

function closeSplitModal() {
  document.getElementById("splitModal").style.display = "none";
  document.getElementById("modalOverlay").style.display = "none";
  selectedExtent = null;
}

function confirmSplit() {
  const splitSize = parseInt(document.getElementById("splitSlider").value);
  if (!selectedExtent) return;

  const totalSize = parseInt(selectedExtent.dataset.pv_size);
  const secondSize = totalSize - splitSize;

  const clone = selectedExtent.cloneNode(true);
  selectedExtent.dataset.pv_size = splitSize;
  selectedExtent.dataset.index += "-1";
  selectedExtent.innerText = `${selectedExtent.dataset.lv_name} #${selectedExtent.dataset.index}:${splitSize}`;

  clone.dataset.index += "-2";
  clone.dataset.pv_size = secondSize;
  clone.dataset.moved_pv_start = parseInt(selectedExtent.dataset.moved_pv_start) + splitSize;
  clone.dataset.pv_start = parseInt(selectedExtent.dataset.pv_start) + splitSize;
  clone.innerText = `${clone.dataset.lv_name} #${clone.dataset.index}:${secondSize}`;

  selectedExtent.parentElement.insertBefore(clone, selectedExtent.nextSibling);

  closeSplitModal();
  updatePVs();
}

window.onload = () => {
  const saved = localStorage.getItem('lvm_json');
  if (saved) {
    document.getElementById('jsonInput').value = saved;
    parseJSON();
  }
};
</script>

</body>
</html>
